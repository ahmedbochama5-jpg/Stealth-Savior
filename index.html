<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø§Ù„Ù…Ù†Ù‚Ø° Ø§Ù„Ø®ÙÙŠ - Ø§Ù„Ù†Ø³Ø®Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c1426, #1a1a2e, #16213e);
            color: white;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 3px solid #06d6a0;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #06d6a0, #9d4edd, #ffd166);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #ccc;
        }
        
        .game-container {
            display: flex;
            flex: 1;
            position: relative;
        }
        
        #game3d {
            flex: 1;
            background: #000;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .stats-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #06d6a0;
            min-width: 200px;
        }
        
        .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .stat-value {
            color: #ffd166;
            font-weight: bold;
        }
        
        .controls-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #9d4edd;
            display: flex;
            gap: 15px;
        }
        
        .btn {
            background: linear-gradient(145deg, #9d4edd, #7b2cbf);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            pointer-events: auto;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(157, 78, 221, 0.4);
        }
        
        .camera-alert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(239, 71, 111, 0.9);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 1.5rem;
            font-weight: bold;
            animation: pulse 1s infinite;
            display: none;
        }
        
        .instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #ffd166;
            max-width: 300px;
        }
        
        .instructions h3 {
            color: #ffd166;
            margin-bottom: 15px;
        }
        
        .instructions ul {
            list-style: none;
            line-height: 1.6;
        }
        
        .instructions li {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .instructions li::before {
            content: "â€¢";
            color: #06d6a0;
            font-weight: bold;
            margin-left: 10px;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        .minimap {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #118ab2;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .vision-cone {
            position: absolute;
            background: linear-gradient(45deg, rgba(255, 0, 0, 0.3), transparent 70%);
            clip-path: polygon(50% 50%, 100% 0, 100% 100%);
            transform-origin: top left;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Ø§Ù„Ù…Ù†Ù‚Ø° Ø§Ù„Ø®ÙÙŠ - Ø§Ù„Ù†Ø³Ø®Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</h1>
            <p class="subtitle">ØªØ¬Ø±Ø¨Ø© Ù„Ø¹Ø¨ ØºØ§Ù…Ø±Ø© ÙÙŠ Ø¹Ø§Ù„Ù… Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</p>
        </header>
        
        <div class="game-container">
            <div id="game3d"></div>
            
            <div class="ui-overlay">
                <div class="stats-panel">
                    <div class="stat">
                        <span>Ø§Ù„Ù…Ø³ØªÙˆÙ‰:</span>
                        <span class="stat-value" id="level">1</span>
                    </div>
                    <div class="stat">
                        <span>Ø§Ù„Ø±Ù‡Ø§Ø¦Ù† Ø§Ù„Ù…Ù†Ù‚Ø°ÙŠÙ†:</span>
                        <span class="stat-value" id="rescued">0/3</span>
                    </div>
                    <div class="stat">
                        <span>Ø§Ù„Ø­Ø§Ù„Ø©:</span>
                        <span class="stat-value" id="status">Ø¢Ù…Ù†</span>
                    </div>
                    <div class="stat">
                        <span>Ø§Ù„Ù‚Ø¯Ø±Ø§Øª:</span>
                        <span class="stat-value" id="abilities">3/3</span>
                    </div>
                </div>
                
                <div class="controls-panel">
                    <button class="btn" id="smokeBtn">Ù‚Ù†Ø¨Ù„Ø© Ø¯Ø®Ø§Ù† (Q)</button>
                    <button class="btn" id="hackBtn">Ø§Ø®ØªØ±Ø§Ù‚ ÙƒØ§Ù…ÙŠØ±Ø§ (H)</button>
                    <button class="btn" id="visionBtn">Ø±Ø¤ÙŠØ© Ù„ÙŠÙ„ÙŠØ© (N)</button>
                    <button class="btn" id="restartBtn">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© (R)</button>
                </div>
                
                <div class="camera-alert" id="cameraAlert">
                    âš ï¸ Ù„Ù‚Ø¯ Ø±ØµØ¯ØªÙƒ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§!
                </div>
                
                <div class="instructions">
                    <h3>ğŸ® ÙƒÙŠÙÙŠØ© Ø§Ù„Ù„Ø¹Ø¨:</h3>
                    <ul>
                        <li>Ø§Ø³ØªØ®Ø¯Ù… WASD Ù„Ù„Ø­Ø±ÙƒØ©</li>
                        <li>Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø§ÙˆØ³ Ù„Ù„Ù†Ø¸Ø± Ø­ÙˆÙ„Ùƒ</li>
                        <li>Ø£Ù†Ù‚Ø° Ø§Ù„Ø±Ù‡Ø§Ø¦Ù† (Ø§Ù„Ù…ÙƒØ¹Ø¨Ø§Øª Ø§Ù„Ø²Ø±Ù‚Ø§Ø¡)</li>
                        <li>ØªØ¬Ù†Ø¨ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª (Ø§Ù„Ø£Ø¶ÙˆØ§Ø¡ Ø§Ù„Ø­Ù…Ø±Ø§Ø¡)</li>
                        <li>Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø®Ø§Ø¨Ø¦ (Ø§Ù„Ù…ÙƒØ¹Ø¨Ø§Øª Ø§Ù„Ø¯Ø§ÙƒÙ†Ø©)</li>
                        <li>Ø§Ø®ØªØ±Ù‚ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª Ù„ØªØ¹Ø·ÙŠÙ„Ù‡Ø§</li>
                    </ul>
                </div>
                
                <div class="minimap" id="minimap"></div>
            </div>
        </div>
    </div>

    <script>
        // Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ©
        let scene, camera, renderer, controls;
        let player, guards = [], hostages = [], cameras = [], walls = [];
        let gameState = {
            level: 1,
            rescued: 0,
            totalHostages: 3,
            abilities: 3,
            maxAbilities: 3,
            playerPosition: { x: 0, y: 0.5, z: 0 },
            status: 'Ø¢Ù…Ù†',
            cameraAlert: false
        };

        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø´Ù‡Ø¯
        function init() {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø´Ù‡Ø¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0c1426);
            scene.fog = new THREE.Fog(0x0c1426, 10, 50);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¹Ø§Ø±Ø¶
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game3d').appendChild(renderer.domElement);

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù…Ø§ÙˆØ³
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 20;

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø±Ø¶ÙŠØ©
            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2d3748,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¨ÙƒØ© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
            const gridHelper = new THREE.GridHelper(50, 50, 0x4a5568, 0x4a5568);
            scene.add(gridHelper);

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù„Ø§Ø¹Ø¨
            createPlayer();
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙŠØ¦Ø©
            createEnvironment();
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø±Ø§Ø³ ÙˆØ§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª
            createGuards();
            createCameras();
            createHostages();

            // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
            setupEventListeners();

            // Ø¨Ø¯Ø¡ Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
            animate();

            // ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            updateUI();
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù„Ø§Ø¹Ø¨
        function createPlayer() {
            const geometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0x06d6a0 });
            player = new THREE.Mesh(geometry, material);
            player.position.set(gameState.playerPosition.x, gameState.playerPosition.y, gameState.playerPosition.z);
            player.castShadow = true;
            scene.add(player);
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙŠØ¦Ø©
        function createEnvironment() {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†
            const wallGeometry = new THREE.BoxGeometry(1, 2, 1);
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
            
            // Ù†Ù…Ø· Ù…ØªØ§Ù‡Ø© Ø¨Ø³ÙŠØ·
            const wallPositions = [
                {x: 5, z: 0}, {x: 5, z: 1}, {x: 5, z: 2}, {x: 5, z: 3},
                {x: -5, z: 0}, {x: -5, z: -1}, {x: -5, z: -2},
                {x: 0, z: 5}, {x: 1, z: 5}, {x: 2, z: 5},
                {x: -3, z: -5}, {x: -2, z: -5}, {x: -1, z: -5},
                {x: 8, z: 8}, {x: 8, z: 7}, {x: 8, z: 6},
                {x: -8, z: 8}, {x: -7, z: 8}, {x: -6, z: 8}
            ];

            wallPositions.forEach(pos => {
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(pos.x, 1, pos.z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                walls.push(wall);
                scene.add(wall);
            });

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø®Ø§Ø¨Ø¦ (Ù…ÙƒØ¹Ø¨Ø§Øª Ø¯Ø§ÙƒÙ†Ø©)
            const hideoutGeometry = new THREE.BoxGeometry(2, 1, 2);
            const hideoutMaterial = new THREE.MeshStandardMaterial({ color: 0x1a202c });
            
            const hideoutPositions = [
                {x: 3, z: 3}, {x: -3, z: 3}, {x: 3, z: -3}, {x: -3, z: -3}
            ];

            hideoutPositions.forEach(pos => {
                const hideout = new THREE.Mesh(hideoutGeometry, hideoutMaterial);
                hideout.position.set(pos.x, 0.5, pos.z);
                hideout.receiveShadow = true;
                scene.add(hideout);
            });
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø±Ø§Ø³
        function createGuards() {
            const geometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0xef476f });
            
            const guardPositions = [
                {x: 8, z: 0, patrol: [{x: 8, z: 0}, {x: 8, z: 4}, {x: 4, z: 4}]},
                {x: -8, z: 0, patrol: [{x: -8, z: 0}, {x: -8, z: -4}, {x: -4, z: -4}]}
            ];

            guardPositions.forEach((pos, index) => {
                const guard = new THREE.Mesh(geometry, material);
                guard.position.set(pos.x, 0.5, pos.z);
                guard.castShadow = true;
                guard.userData = {
                    patrolPoints: pos.patrol,
                    currentPatrolIndex: 0,
                    alert: false,
                    target: null,
                    speed: 0.02
                };
                guards.push(guard);
                scene.add(guard);
            });
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª
        function createCameras() {
            const cameraGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 8);
            const cameraMaterial = new THREE.MeshStandardMaterial({ color: 0xff9800 });
            
            const cameraPositions = [
                {x: 10, z: 10, direction: new THREE.Vector3(-1, 0, -1)},
                {x: -10, z: 10, direction: new THREE.Vector3(1, 0, -1)},
                {x: 0, z: -10, direction: new THREE.Vector3(0, 0, 1)}
            ];

            cameraPositions.forEach((pos, index) => {
                const cameraObj = new THREE.Mesh(cameraGeometry, cameraMaterial);
                cameraObj.position.set(pos.x, 2, pos.z);
                cameraObj.castShadow = true;
                
                // Ø¥Ø¶Ø§ÙØ© Ø¶ÙˆØ¡ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§
                const cameraLight = new THREE.SpotLight(0xff4444, 2, 10, Math.PI / 6, 0.5);
                cameraLight.position.set(0, 0, 0);
                cameraLight.target.position.copy(pos.direction);
                cameraLight.castShadow = true;
                cameraObj.add(cameraLight);
                
                cameraObj.userData = {
                    active: false,
                    hacked: false,
                    direction: pos.direction,
                    light: cameraLight
                };
                cameras.push(cameraObj);
                scene.add(cameraObj);
                scene.add(cameraLight.target);
            });
        }

        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ù‡Ø§Ø¦Ù†
        function createHostages() {
            const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const material = new THREE.MeshStandardMaterial({ color: 0x118ab2 });
            
            const hostagePositions = [
                {x: 7, z: 7}, {x: -7, z: 7}, {x: 7, z: -7}
            ];

            hostagePositions.forEach((pos, index) => {
                const hostage = new THREE.Mesh(geometry, material);
                hostage.position.set(pos.x, 0.4, pos.z);
                hostage.castShadow = true;
                hostage.userData = { rescued: false };
                hostages.push(hostage);
                scene.add(hostage);
            });
        }

        // Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø³ØªÙ…Ø¹ÙŠ Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
        function setupEventListeners() {
            document.addEventListener('keydown', handleKeyPress);
            document.getElementById('smokeBtn').addEventListener('click', useSmokeGrenade);
            document.getElementById('hackBtn').addEventListener('click', hackCamera);
            document.getElementById('visionBtn').addEventListener('click', useNightVision);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            window.addEventListener('resize', onWindowResize);
        }

        // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø¶ØºØ·Ø§Øª Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        function handleKeyPress(event) {
            const speed = 0.2;
            
            switch(event.key.toLowerCase()) {
                case 'w':
                    player.position.z -= speed;
                    break;
                case 's':
                    player.position.z += speed;
                    break;
                case 'a':
                    player.position.x -= speed;
                    break;
                case 'd':
                    player.position.x += speed;
                    break;
                case 'q':
                    useSmokeGrenade();
                    break;
                case 'h':
                    hackCamera();
                    break;
                case 'n':
                    useNightVision();
                    break;
                case 'r':
                    restartGame();
                    break;
            }
            
            // ØªØ­Ø¯ÙŠØ« Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
            gameState.playerPosition.x = player.position.x;
            gameState.playerPosition.z = player.position.z;
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…Ø§Øª ÙˆØ§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª
            checkCollisions();
            checkCameraDetection();
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…Ø§Øª
        function checkCollisions() {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØµØ·Ø¯Ø§Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†
            const playerBox = new THREE.Box3().setFromObject(player);
            
            for (const wall of walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);
                if (playerBox.intersectsBox(wallBox)) {
                    // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¥Ù„Ù‰ Ù…ÙˆÙ‚Ø¹Ù‡ Ø§Ù„Ø³Ø§Ø¨Ù‚
                    player.position.x = gameState.playerPosition.x;
                    player.position.z = gameState.playerPosition.z;
                    break;
                }
            }
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù†Ù‚Ø§Ø° Ø§Ù„Ø±Ù‡Ø§Ø¦Ù†
            for (const hostage of hostages) {
                if (!hostage.userData.rescued) {
                    const distance = player.position.distanceTo(hostage.position);
                    if (distance < 1.5) {
                        hostage.userData.rescued = true;
                        hostage.material.color.set(0x06d6a0); // ØªØºÙŠÙŠØ± Ø§Ù„Ù„ÙˆÙ† Ù„Ù„Ø¥Ø´Ø§Ø±Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¥Ù†Ù‚Ø§Ø°
                        gameState.rescued++;
                        updateUI();
                        
                        if (gameState.rescued === gameState.totalHostages) {
                            setTimeout(() => {
                                alert('Ù…Ø¨Ø±ÙˆÙƒ! Ø£Ù†Ù‚Ø°Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù‡Ø§Ø¦Ù†!');
                                nextLevel();
                            }, 500);
                        }
                    }
                }
            }
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ØµØ·Ø¯Ø§Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¨Ø§Ù„Ø­Ø±Ø§Ø³
            for (const guard of guards) {
                const distance = player.position.distanceTo(guard.position);
                if (distance < 1.5 && guard.userData.alert) {
                    alert('Ù„Ù‚Ø¯ Ù‚Ø¨Ø¶ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø­Ø§Ø±Ø³! Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.');
                    restartGame();
                }
            }
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§ÙƒØªØ´Ø§Ù Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª
        function checkCameraDetection() {
            let detected = false;
            
            for (const cameraObj of cameras) {
                if (cameraObj.userData.hacked) continue;
                
                const direction = new THREE.Vector3();
                cameraObj.getWorldDirection(direction);
                const toPlayer = new THREE.Vector3().subVectors(player.position, cameraObj.position).normalize();
                
                const dotProduct = direction.dot(toPlayer);
                const distance = player.position.distanceTo(cameraObj.position);
                
                // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙÙŠ Ù…Ø¬Ø§Ù„ Ø±Ø¤ÙŠØ© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
                if (dotProduct > 0.8 && distance < 8) {
                    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø¹ÙˆØ§Ø¦Ù‚
                    const raycaster = new THREE.Raycaster(
                        cameraObj.position,
                        toPlayer,
                        0.1,
                        distance
                    );
                    
                    const intersects = raycaster.intersectObjects(walls);
                    
                    if (intersects.length === 0) {
                        cameraObj.userData.active = true;
                        cameraObj.material.color.set(0xff4444);
                        cameraObj.userData.light.color.set(0xff4444);
                        detected = true;
                        
                        // ØªÙ†Ø¨ÙŠÙ‡ Ø§Ù„Ø­Ø±Ø§Ø³
                        for (const guard of guards) {
                            guard.userData.alert = true;
                            guard.userData.target = player.position.clone();
                            guard.material.color.set(0xff0000);
                        }
                    }
                } else {
                    cameraObj.userData.active = false;
                    cameraObj.material.color.set(0xff9800);
                    cameraObj.userData.light.color.set(0xff9800);
                }
            }
            
            // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨
            if (detected && !gameState.cameraAlert) {
                gameState.cameraAlert = true;
                gameState.status = 'Ù…ÙƒØ´ÙˆÙ!';
                document.getElementById('cameraAlert').style.display = 'block';
            } else if (!detected && gameState.cameraAlert) {
                gameState.cameraAlert = false;
                gameState.status = 'Ø¢Ù…Ù†';
                document.getElementById('cameraAlert').style.display = 'none';
                
                // Ø¥Ù„ØºØ§Ø¡ ØªÙ†Ø¨ÙŠÙ‡ Ø§Ù„Ø­Ø±Ø§Ø³
                for (const guard of guards) {
                    guard.userData.alert = false;
                    guard.material.color.set(0xef476f);
                }
            }
            
            updateUI();
        }

        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‚Ù†Ø¨Ù„Ø© Ø¯Ø®Ø§Ù†
        function useSmokeGrenade() {
            if (gameState.abilities > 0) {
                gameState.abilities--;
                
                // Ø¥Ù†Ø´Ø§Ø¡ ØªØ£Ø«ÙŠØ± Ø¯Ø®Ø§Ù†
                const smokeGeometry = new THREE.SphereGeometry(3, 8, 8);
                const smokeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x888888,
                    transparent: true,
                    opacity: 0.6
                });
                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                smoke.position.copy(player.position);
                scene.add(smoke);
                
                // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…Ø¤Ù‚ØªÙ‹Ø§ Ù…Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª
                setTimeout(() => {
                    scene.remove(smoke);
                }, 5000);
                
                updateUI();
            }
        }

        // Ø§Ø®ØªØ±Ø§Ù‚ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
        function hackCamera() {
            if (gameState.abilities > 0) {
                let hacked = false;
                
                for (const cameraObj of cameras) {
                    const distance = player.position.distanceTo(cameraObj.position);
                    if (distance < 5 && !cameraObj.userData.hacked) {
                        cameraObj.userData.hacked = true;
                        cameraObj.userData.active = false;
                        cameraObj.material.color.set(0x666666);
                        cameraObj.userData.light.intensity = 0;
                        hacked = true;
                        gameState.abilities--;
                        break;
                    }
                }
                
                if (hacked) {
                    updateUI();
                }
            }
        }

        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ù„ÙŠÙ„ÙŠØ©
        function useNightVision() {
            if (gameState.abilities > 0) {
                gameState.abilities--;
                
                // ØªØ·Ø¨ÙŠÙ‚ ØªØ£Ø«ÙŠØ± Ø§Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ù„ÙŠÙ„ÙŠØ©
                scene.background = new THREE.Color(0x00ff00);
                scene.fog = new THREE.Fog(0x00ff00, 20, 100);
                
                setTimeout(() => {
                    scene.background = new THREE.Color(0x0c1426);
                    scene.fog = new THREE.Fog(0x0c1426, 10, 50);
                }, 10000);
                
                updateUI();
            }
        }

        // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø­Ø±Ø§Ø³
        function updateGuards() {
            for (const guard of guards) {
                if (guard.userData.alert && guard.userData.target) {
                    // Ø§Ù„ØªØ­Ø±Ùƒ Ù†Ø­Ùˆ Ø§Ù„Ù‡Ø¯Ù
                    const direction = new THREE.Vector3().subVectors(guard.userData.target, guard.position).normalize();
                    guard.position.add(direction.multiplyScalar(guard.userData.speed));
                    
                    // Ø§Ù„ØªØ¯ÙˆÙŠØ± Ù†Ø­Ùˆ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø­Ø±ÙƒØ©
                    guard.lookAt(guard.userData.target);
                } else {
                    // Ø­Ø±ÙŠØ© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†
                    guard.rotation.y += 0.01;
                }
            }
        }

        // ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        function updateUI() {
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('rescued').textContent = `${gameState.rescued}/${gameState.totalHostages}`;
            document.getElementById('status').textContent = gameState.status;
            document.getElementById('abilities').textContent = `${gameState.abilities}/${gameState.maxAbilities}`;
        }

        // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ
        function nextLevel() {
            gameState.level++;
            gameState.rescued = 0;
            gameState.abilities = gameState.maxAbilities;
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹
            player.position.set(0, 0.5, 0);
            gameState.playerPosition = { x: 0, y: 0.5, z: 0 };
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø±Ù‡Ø§Ø¦Ù†
            hostages.forEach(hostage => {
                hostage.userData.rescued = false;
                hostage.material.color.set(0x118ab2);
            });
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª
            cameras.forEach(camera => {
                camera.userData.hacked = false;
                camera.userData.active = false;
                camera.material.color.set(0xff9800);
                camera.userData.light.intensity = 2;
            });
            
            // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ø±Ø§Ø³
            guards.forEach(guard => {
                guard.userData.alert = false;
                guard.material.color.set(0xef476f);
            });
            
            updateUI();
        }

        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©
        function restartGame() {
            gameState.rescued = 0;
            gameState.abilities = gameState.maxAbilities;
            gameState.status = 'Ø¢Ù…Ù†';
            gameState.cameraAlert = false;
            
            player.position.set(0, 0.5, 0);
            gameState.playerPosition = { x: 0, y: 0.5, z: 0 };
            
            hostages.forEach(hostage => {
                hostage.userData.rescued = false;
                hostage.material.color.set(0x118ab2);
            });
            
            cameras.forEach(camera => {
                camera.userData.hacked = false;
                camera.userData.active = false;
                camera.material.color.set(0xff9800);
                camera.userData.light.intensity = 2;
            });
            
            guards.forEach(guard => {
                guard.userData.alert = false;
                guard.material.color.set(0xef476f);
            });
            
            document.getElementById('cameraAlert').style.display = 'none';
            updateUI();
        }

        // ØªØ¹Ø¯ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
        function animate() {
            requestAnimationFrame(animate);
            
            updateGuards();
            controls.update();
            
            renderer.render(scene, camera);
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        init();
    </script>
</body>
</html>
